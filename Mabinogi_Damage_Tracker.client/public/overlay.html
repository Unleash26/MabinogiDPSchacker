<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Damage Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            background: transparent;
            font-family: 'Segoe UI', 'Yu Gothic UI', sans-serif;
            color: #e0e0e0;
            overflow-y: auto;
            overflow-x: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        body::-webkit-scrollbar {
            width: 4px;
        }

        body::-webkit-scrollbar-track {
            background: transparent;
        }

        body::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .card {
            background: rgba(28, 28, 30, 0.85);
            border-radius: 12px;
            padding: 12px 16px;
            margin: 4px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .card-title {
            font-size: 13px;

            font-weight: 700;
            letter-spacing: 0.3px;
        }

        .player-select {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
            outline: none;
        }

        .player-select option {
            background: #1c1c1e;
            color: #e0e0e0;
        }

        .chart-area {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .donut-container {
            position: relative;
            width: 110px;
            height: 110px;
            flex-shrink: 0;
        }

        .donut-container canvas {
            width: 110px;
            height: 110px;
        }

        .donut-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }

        .donut-center .total-value {
            font-size: 18px;
            font-weight: 800;
            color: #fff;
            line-height: 1.1;
        }

        .donut-center .total-label {
            font-size: 8px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend {
            flex: 1;
            overflow-y: auto;
            max-height: 200px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 2px 0;
            font-size: 12px;
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            flex-shrink: 0;
        }

        .legend-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 6px;
        }

        .legend-value {
            text-align: right;
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
            color: #ccc;
            font-size: 11px;
        }

        .no-data {
            text-align: center;
            color: #888;
            padding: 20px 0;
            font-size: 12px;
            width: 100%;
        }

        .dps-canvas-container {
            width: 100%;
            height: 120px;
            position: relative;
        }

        .dps-canvas-container canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <div class="card">
        <div class="card-header">
            <span class="card-title">スキル別ダメージ</span>
            <select id="playerSelect" class="player-select">
                <option value="__all__">全員</option>
            </select>
        </div>
        <div class="chart-area" id="chartArea">
            <div class="no-data">データがありません</div>
        </div>
    </div>

    <div class="card">
        <div class="card-header">
            <span class="card-title">ダメージ推移</span>
        </div>
        <div class="dps-canvas-container">
            <canvas id="dpsCanvas"></canvas>
        </div>
    </div>

    <script>
        const COLORS = [
            '#8684BF', '#81B7C7', '#7ECFA1', '#9CD67A', '#DECC76',
            '#E67470', '#ED6BCD', '#A564F5', '#5D95FC', '#54FFE5',
            '#4AFF53', '#CFFF40', '#FF9036', '#FF2B72', '#E121FF'
        ];
        const API_BASE = `http://${window.location.hostname}:5004/Home`;

        let skillTranslations = {};
        let accumulatedSkillData = {};
        let selectedPlayer = '__all__';
        let skillLastFetchedId = 0;
        let skillInitialized = false;

        // DPS
        let dpsPlayers = {};          // keyed by display name
        let dpsLastFetchedId = 0;
        let dpsInitialized = false;

        // Session baseline tracking (for reset detection)
        let currentBaselineId = 0;

        // Known player names from skill data (correct names)
        let knownPlayerNames = {};    // { playerId -> playerName }

        fetch('/skill_names_ja.json')
            .then(r => r.json())
            .then(d => { skillTranslations = d.skillNameTranslations || d; })
            .catch(() => { });

        function translateSkill(name) { return skillTranslations[name] || name; }

        function formatDamage(v) {
            if (v >= 1e6) return (v / 1e6).toFixed(1) + 'M';
            if (v >= 1e3) return (v / 1e3).toFixed(1) + 'K';
            return Math.round(v).toString();
        }

        // ========== RESET ==========
        function resetAll() {
            accumulatedSkillData = {};
            selectedPlayer = '__all__';
            skillLastFetchedId = 0;
            skillInitialized = false;
            dpsPlayers = {};
            dpsLastFetchedId = 0;
            dpsInitialized = false;
            knownPlayerNames = {};
            updatePlayerSelect();
            renderSkillCard();
            drawDpsChart();
        }

        // Check if DB was cleared (measurement restarted)
        // Check if Session Baseline changed (measurement restarted)
        async function checkForReset() {
            try {
                // Add timestamp to prevent caching
                const res = await fetch(`${API_BASE}/GetLastDamageRowId?_=${Date.now()}`);
                const json = await res.json();
                // Handle both PascalCase (C# default) and CamelCase
                const remoteBaseline = json.baseline || json.Baseline || 0;

                console.log(`[Overlay] CheckReset: current=${currentBaselineId}, remote=${remoteBaseline}`);

                // If remote baseline is NEWER than our current baseline, it means a NEW session started.
                // Note: This also handles the 0 -> N transition (Start Recording)
                if (remoteBaseline > currentBaselineId) {
                    console.log(`[Overlay] RESET TRIGGERED! (Baseline: ${currentBaselineId} -> ${remoteBaseline})`);
                    resetAll();
                    currentBaselineId = remoteBaseline;
                    // Start fetching from the new baseline
                    skillLastFetchedId = remoteBaseline;
                    dpsLastFetchedId = remoteBaseline;
                    skillInitialized = true;
                    dpsInitialized = true;
                    return true;
                }
            } catch (e) { console.error(e); }

            return false;
        }

        // ========== SKILL DAMAGE ==========
        function getSkillsForDisplay() {
            const pids = Object.keys(accumulatedSkillData);
            if (pids.length === 0) return [];
            if (selectedPlayer === '__all__') {
                const merged = {};
                for (const pid of pids) {
                    for (const [sn, dmg] of Object.entries(accumulatedSkillData[pid].skills)) {
                        merged[sn] = (merged[sn] || 0) + dmg;
                    }
                }
                return Object.entries(merged).map(([s, d]) => ({ skillName: s, damage: d })).sort((a, b) => b.damage - a.damage);
            } else {
                const p = accumulatedSkillData[selectedPlayer];
                if (!p) return [];
                return Object.entries(p.skills).map(([s, d]) => ({ skillName: s, damage: d })).sort((a, b) => b.damage - a.damage);
            }
        }

        function drawDonut(canvas, skills, totalDamage) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 110 * dpr; canvas.height = 110 * dpr;
            ctx.scale(dpr, dpr); ctx.clearRect(0, 0, 110, 110);
            const cx = 55, cy = 55, oR = 50, iR = 33;
            if (totalDamage === 0) {
                ctx.beginPath(); ctx.arc(cx, cy, oR, 0, Math.PI * 2);
                ctx.arc(cx, cy, iR, 0, Math.PI * 2, true);
                ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill(); return;
            }
            let a = -Math.PI / 2;
            skills.forEach((s, i) => {
                const sa = (s.damage / totalDamage) * Math.PI * 2;
                ctx.beginPath(); ctx.arc(cx, cy, oR, a, a + sa);
                ctx.arc(cx, cy, iR, a + sa, a, true); ctx.closePath();
                ctx.fillStyle = COLORS[i % COLORS.length]; ctx.fill();
                a += sa;
            });
        }

        function renderSkillCard() {
            const skills = getSkillsForDisplay();
            const ca = document.getElementById('chartArea');
            if (skills.length === 0) { ca.innerHTML = '<div class="no-data">データがありません</div>'; return; }
            const total = skills.reduce((s, x) => s + x.damage, 0);
            let h = `<div class="donut-container"><canvas id="donutCanvas" width="110" height="110"></canvas>
    <div class="donut-center"><div class="total-value">${formatDamage(total)}</div><div class="total-label">TOTAL</div></div></div><div class="legend">`;
            skills.forEach((s, i) => {
                const pct = total > 0 ? ((s.damage / total) * 100).toFixed(1) : '0.0';
                h += `<div class="legend-item"><span class="legend-dot" style="background:${COLORS[i % COLORS.length]}"></span>
      <span class="legend-name">${translateSkill(s.skillName)}</span>
      <span class="legend-value">${formatDamage(s.damage)} (${pct}%)</span></div>`;
            });
            h += '</div>';
            ca.innerHTML = h;
            const c = document.getElementById('donutCanvas');
            if (c) drawDonut(c, skills, total);
        }

        function updatePlayerSelect() {
            const sel = document.getElementById('playerSelect');
            const prev = sel.value;
            sel.innerHTML = '<option value="__all__">全員</option>';
            for (const pid of Object.keys(accumulatedSkillData)) {
                const o = document.createElement('option');
                o.value = pid; o.textContent = accumulatedSkillData[pid].playerName;
                sel.appendChild(o);
            }
            sel.value = prev; if (!sel.value) sel.value = '__all__';
            selectedPlayer = sel.value;
        }

        document.getElementById('playerSelect').addEventListener('change', e => {
            selectedPlayer = e.target.value; renderSkillCard();
        });

        function mergeSkillData(data) {
            for (const p of data) {
                const pid = String(p.playerId);
                if (!accumulatedSkillData[pid]) accumulatedSkillData[pid] = { playerName: p.playerName, skills: {} };
                accumulatedSkillData[pid].playerName = p.playerName;
                knownPlayerNames[pid] = p.playerName;
                for (const s of p.skills) {
                    accumulatedSkillData[pid].skills[s.skillName] = (accumulatedSkillData[pid].skills[s.skillName] || 0) + s.damage;
                }
            }
        }

        async function fetchSkillData() {
            try {
                const res = await fetch(`${API_BASE}/GetDamageBySkillAfterId?lastFetchedId=${skillLastFetchedId}`);
                const json = await res.json();
                if (json && json.lastId) {
                    if (!skillInitialized) { skillLastFetchedId = json.lastId; skillInitialized = true; return; }
                    if (json.data) { mergeSkillData(json.data); skillLastFetchedId = json.lastId; updatePlayerSelect(); renderSkillCard(); }
                } else if (!skillInitialized) { skillInitialized = true; }
            } catch (e) { }
        }

        // ========== DPS CHART ==========
        // Player name map: { playerId -> displayName }
        // Merges DB names with localStorage custom_names (same logic as AppContext)
        let playerNameMap = {};  // { "12345": "あやねまる", ... }

        async function fetchPlayerNameMap() {
            try {
                const res = await fetch(`${API_BASE}/GetAllPlayers`);
                const json = await res.json();
                // Read custom names from localStorage (same key as React AppContext)
                let customNames = {};
                try { customNames = JSON.parse(localStorage.getItem('custom_names') || '{}'); } catch (e) { }

                // Parse response: Ok(Json(list)) -> { value: [...] }
                let players = null;
                if (Array.isArray(json)) {
                    players = json;
                } else if (json && json.value) {
                    if (Array.isArray(json.value)) {
                        players = json.value;
                    } else if (json.value && json.value.value && Array.isArray(json.value.value)) {
                        players = json.value.value;
                    }
                }
                if (players) {
                    const map = {};
                    players.forEach(p => {
                        // Priority: custom name > DB name
                        map[String(p.playerId)] = customNames[p.playerId] || customNames[String(p.playerId)] || p.playerName;
                    });
                    playerNameMap = map;
                }
            } catch (e) { }
        }

        function resolvePlayerName(label, playerId) {
            const pidStr = String(playerId);
            // First try: look up by playerId in the name map (DB/Custom)
            if (playerId && playerNameMap[pidStr]) {
                const mapped = playerNameMap[pidStr];
                // Only use if it's not a placeholder
                if (!mapped.startsWith('<') || !mapped.endsWith('>')) return mapped;
            }
            // Second try: look up in knownPlayerNames (from Skill Data)
            if (playerId && knownPlayerNames[pidStr]) {
                return knownPlayerNames[pidStr];
            }
            // Second try: if label is a placeholder, use first non-placeholder name from the map
            if (label && label.startsWith('<') && label.endsWith('>')) {
                const realNames = Object.values(playerNameMap).filter(n => !n.startsWith('<') || !n.endsWith('>'));
                if (realNames.length > 0) return realNames[0];
            }
            return label;
        }

        function drawDpsChart() {
            const canvas = document.getElementById('dpsCanvas');
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const w = container.clientWidth, h = container.clientHeight;
            canvas.width = w * dpr; canvas.height = h * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr); ctx.clearRect(0, 0, w, h);

            const playerKeys = Object.keys(dpsPlayers);
            if (playerKeys.length === 0) {
                ctx.fillStyle = '#888'; ctx.font = '12px "Segoe UI"'; ctx.textAlign = 'center';
                ctx.fillText('データがありません', w / 2, h / 2); return;
            }

            const pad = { top: 14, right: 10, bottom: 20, left: 45 };
            const cw = w - pad.left - pad.right, ch = h - pad.top - pad.bottom;

            let maxVal = 0, maxLen = 0;
            for (const key of playerKeys) {
                const cd = dpsPlayers[key].cumulativeData;
                maxLen = Math.max(maxLen, cd.length);
                for (const v of cd) maxVal = Math.max(maxVal, v);
            }
            if (maxVal === 0) maxVal = 1;
            if (maxLen <= 1) maxLen = 2;

            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + ch - (i / 4) * ch;
                ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + cw, y); ctx.stroke();
                ctx.fillStyle = '#888'; ctx.font = '9px "Segoe UI"'; ctx.textAlign = 'right';
                ctx.fillText(formatDamage((maxVal * i) / 4), pad.left - 4, y + 3);
            }

            ctx.fillStyle = '#666'; ctx.font = '9px "Segoe UI"'; ctx.textAlign = 'center';
            const li = Math.max(1, Math.floor(maxLen / 5));
            for (let i = 0; i < maxLen; i += li) {
                const x = pad.left + (i / (maxLen - 1)) * cw;
                ctx.fillText(i + 's', x, h - 4);
            }

            playerKeys.forEach((key, pi) => {
                const cd = dpsPlayers[key].cumulativeData;
                ctx.strokeStyle = COLORS[pi % COLORS.length]; ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < cd.length; i++) {
                    const x = pad.left + (i / (maxLen - 1)) * cw;
                    const y = pad.top + ch - (cd[i] / maxVal) * ch;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            });

            let lx = pad.left; ctx.font = '10px "Segoe UI"';
            playerKeys.forEach((key, pi) => {
                ctx.fillStyle = COLORS[pi % COLORS.length]; ctx.fillRect(lx, 2, 8, 8);
                ctx.fillStyle = '#ccc'; ctx.textAlign = 'left';
                ctx.fillText(dpsPlayers[key].name, lx + 10, 9);
                lx += ctx.measureText(dpsPlayers[key].name).width + 20;
            });
        }

        async function fetchDpsData() {
            try {
                const res = await fetch(`${API_BASE}/GetAllDamagesGroupedByPlayersAfterId?lastFetchedId=${dpsLastFetchedId}`);
                const json = await res.json();
                if (json && json.lastId) {
                    if (!dpsInitialized) { dpsLastFetchedId = json.lastId; dpsInitialized = true; return; }
                    if (json.data) {
                        for (const p of json.data) {
                            // Resolve: use real player name instead of <SKILL>
                            const displayName = resolvePlayerName(p.label, p.id);

                            // Merge all entries (including <SKILL> and real name) into one
                            if (!dpsPlayers[displayName]) {
                                dpsPlayers[displayName] = { name: displayName, cumulativeData: [] };
                            }

                            const existing = dpsPlayers[displayName].cumulativeData;
                            const lastCum = existing.length > 0 ? existing[existing.length - 1] : 0;
                            let runningTotal = lastCum;
                            for (const dmg of p.data) {
                                runningTotal += dmg;
                                existing.push(runningTotal);
                            }
                        }
                        dpsLastFetchedId = json.lastId;
                        drawDpsChart();
                    }
                } else if (!dpsInitialized) { dpsInitialized = true; }
            } catch (e) { }
        }

        // ========== MAIN LOOP ==========
        async function tick() {
            const wasReset = await checkForReset();
            if (wasReset) return;
            // Fetch player name map every tick (localStorage custom_names + DB)
            await fetchPlayerNameMap();
            await Promise.all([fetchSkillData(), fetchDpsData()]);
        }

        tick();
        setInterval(tick, 500);
        window.addEventListener('resize', () => { drawDpsChart(); });
    </script>
</body>

</html>